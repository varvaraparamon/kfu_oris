# Синхронизация потоков

Многопоточность позволяет выполнять несколько задач типа одновременно (обсуждали на прошлой паре, что это из-за GIL) в рамках одного процесса

Мы уже говорили о таких вещах как Race Condition, Deadlock и о том, как с помощью блокировок Lock b RLock данные проблемы можно решить

Но на самом деле у нас есть еще некоторые инструменты синхронизации для координации работы потоков и защиты каких-то общих ресурсов

## Timer

**Timer** - это поток, который запускает указанную функцию через заданный промежуток времени

**Основные методы:**
* Timer(interval, function, args=None, kwargs=None) - конструктор (kwargs - именованные аргументы)
* start() - запуск таймера
* cancel() - отмена таймера (но этот метод работает только в том случае, когда таймер еще не сработал, если функция уже потоком выполняется, то ее уже не отменить)

Принцип работы:
1. Создается отдельный поток
2. Поток ждет указанный интервал времени
3. Выполняет целевую функцию
4. Автоматически завершается

Применяется:
* Будильники и напоминания
* Отложенное выполнение задач
* Таймауты операций
* Периодические проверки/операции

У вас наверняка появился вопрос: "А в чем проблема юзать time.sleep() и Thread запускать после него?". И этот вопрос логичный! А вот и причины:
1. Чистый код и понятный (а в случае с засыпанием непонятно, зачем вы его использовали, если ваш код кто-то будет смотреть)
2. До срабатывания функции, пока таймер отсчитывает время, вы можете отменить этот поток, а вот во время sleep() обычный поток никак не отменить

Вариант использования:
```python
import threading
import time

def good_way():
    def task():
        print("Супер-пупер!")
    
    timer = threading.Timer(5.0, task) # ждем 5 секунд
    timer.start()
    
    # а пока отсчитывается таймер, наша программа может делать другие дела
    for i in range(10):
        print(f"Делаю какую-то полезную работу {i}")
        time.sleep(0.5)

good_way()
```

**Типичный пример** - напоминания, автосохранения и тд

### Задача №1

**Класс TextEditor**
Реализуйте класс TextEditor со следующим функционалом:

**Атрибуты:**
* auto_save_timer - для хранения активного таймера автосохранения
* unsaved_changes - флаг наличия несохраненных изменений (True/False)
* content - строка с содержимым документа
* save_count - счетчик выполненных сохранений
* auto_save_interval - интервал автосохранения в секундах (по умолчанию 3)

Методы:
__init__(auto_save_interval=3, max_auto_saves=None) - инициализирует все атрибуты
auto_save() - выполняет автоматическое сохранение если есть несохраненные изменения + логирует операцию с содержимым документа
manual_save() - выполняет принудительное сохранение по команде пользователя + также логирует операцию
close() - закрывает редактор, если есть несохраненные изменения - выполняет автосохранение + также логируем статистику по сохранениям

## Barrier

**Barrier** - механизм синхронизации потоков, который заставляет потоки ждать друг друга в определенной точке

Аналогия - светофор, который дожидается конкретное количество человек и только потом включает зеленый

**Основные методы:**
* Barrier(parties, action=None, timeout=None) - конструктор 
  * parties - кол-во потоков, которые должны собраться у барьера
  * action - функция, которая выполняется когда все потоки собрались (перед их пробуждением)
  * timeout - время ожидания по умолчанию для методов wait()
* wait(timeout=None) - ожидание других потоков
  * поток подходит к барьеру и ждет остальных
  * если указан timeout и время истекло - бросает BrokenBarrierError
* reset() - сброс барьера
  * сбрасывает барьер в начальное состояние
  * все потоки, которые уже ожидали, получают BrokenBarrierError
* abort() - прерывание ожидания
  * прерывает ожидание всех потоков
  * барьер переходит типа в сломанное состояние

Когда все потоки достигли барьера, они одновременно продолжают работу

```python
import threading
import time

def barrier_action():
    print("Все потоки достигли барьера! Запускаем какую-то общую задачу")

barrier = threading.Barrier(3, action=barrier_action)

def worker(name):
    print(f"Поток {name} начал работу")
    time.sleep(1)
    print(f"Поток {name} ожидает у барьера")
    barrier.wait()
    print(f"Поток {name} продолжил работу")

threads = []
for i in range(3):
    t = threading.Thread(target=worker, args=(f"Thread-{i+1}",))
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

### Задача №2

Разработать систему для параллельного чтения файлов с числами и вычисления общей суммы всех чисел с использованием потоков и барьера для синхронизации

Описание:
Есть набор текстовых файлов, каждый из которых содержит числа (по одному числу на строку). Необходимо создать многопоточное приложение, которое:
1) Параллельно обрабатывает файлы - разные потоки читают разные файлы одновременно
2) Суммирует числа - каждый поток вычисляет сумму чисел в своих файлах
3) Синхронизирует результаты - с помощью барьера дожидается завершения всех потоков
4) Выводит общую сумму - после завершения всех потоков отображает итоговый результат

Методы:
* __init__(num_workers=2) - инициализация с указанием количества рабочих потоков
* process_number_file(filename, worker_id) - обработка одного файла (чтение и суммирование чисел)
* worker(file_list, worker_id) - рабочий поток, обрабатывающий список файлов
* process_files(file_list) - основной метод для запуска обработки

Обязательно логируем эти вещи:
- когда поток начинает работу
- когда файл успешно обработан
- когда возникают ошибки
- когда все потоки завершили работу
- итоговую статистику

## Semaphore

**Semaphore** - счетчик, ограничивающий количество потоков, которые могут одновременно получить доступ к ресурсу

**Основные методы:**
* Semaphore(value=1) - конструктор
  * value - начальное значение счетчика (сколько потоков могут одновременно получить доступ)
* acquire(blocking=True, timeout=None) - захват семафора
  * захватывает семафор (уменьшает счетчик на 1)
  * если счетчик > 0 - поток продолжает работу 
  * если счетчик = 0 - поток блокируется пока другой поток не освободит семафор 
  * blocking - если False, не блокируется, а сразу возвращает результат 
  * timeout - максимальное время ожидания
* release() - освобождение семафора
  * освобождает семафор (увеличивает счетчик на 1)
  * будит один из ожидающих потоков

```python
import threading
import time

semaphore = threading.Semaphore(2)  # максимум 2 потока одновременно

def worker(thread_id):
    print(f"Поток {thread_id} пытается захватить семафор...")
    
    # захватываем семафор
    semaphore.acquire()
    print(f"Поток {thread_id} захватил семафор! Работает...")
    
    # имитация работы
    time.sleep(2)
    
    # освобождаем семафор
    print(f"Поток {thread_id} освобождает семафор")
    semaphore.release()

threads = []
for i in range(5):
    t = threading.Thread(target=worker, args=(i,))
    threads.append(t)
    t.start()
    time.sleep(0.5)  # небольшая задержка между созданием потоков

for t in threads:
    t.join()
```

### Задача №3

Реализовать класс LogGenerator, который создает несколько потоков для параллельной генерации логов разных типов

1. Класс LogGenerator должен:
* Инициализировать семафор с ограничением на 2 одновременные записи
* Содержать метод generate_log() для генерации логов определенного типа
* Содержать метод _write_log() для безопасной записи в файл с использованием семафора

2. Логи должны содержать:
* Временную метку
* Тип лога (INFO, ERROR, WARNING, DEBUG, SUCCESS)
* ID потока
* Текст сообщения

3. Запустить 5 потоков, каждый генерирует логи своего типа

Для получения нынешнего времени можно сделать так:
```python
timestamp = datetime.now().strftime("%H:%M:%S")
```


