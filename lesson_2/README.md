# Дескриптор

**Дескриптор** - это целое число (идентификатор), которое операционная система выдаёт программе, когда она открывает файл, создаёт сетевое соединение или обращается к другому ресурсу

В операционных системах всё - это файлы: обычные файлы, сокеты, каналы, устройства. Это значит, что любой ресурс выглядит для программы одинаково - как поток байтов, к которому можно читать/писать 

По договорённости в Unix-подобных ОС у каждого процесса при старте сразу есть:

* 0 -> стандартный ввод (stdin)
* 1 -> стандартный вывод (stdout)
* 2 -> стандартный поток ошибок (stderr)

Это сделано, чтобы у программы всегда был базовый способ получать данные и что-то выводить

Если у вас MacOS/Linux, можно глянуть дескрипторы какого-нибудь приложения. Возьмем Google Chrome

1. Найдём PID Chrome с помощью команды в терминале: **ps aux | grep "Google Chrome"**
2. Вывод будет что-то вроде: 

user   12345   0.0  ...  /Applications/Google Chrome.app/Contents/MacOS/Google Chrome

3. Берем как раз этот 12345 - это PID - айдишник вашего процесса
4. Выполняем команду: **lsof -p 12345**
5. Данная команда выведет список всех файлов/сокетов/устройств, открытых этим процессом:
   
    Google Ch 12345 user  txt    REG    ... /Applications/Google Chrome.app/Contents/MacOS/Google Chrome 
    
    Google Ch 12345 user  123u   IPv4   ... TCP 192.168.0.10:56789->142.250.74.14:443 (ESTABLISHED)
    
    Google Ch 12345 user  124u   REG    ... /Users/user/Library/Caches/Google/Chrome/Cache/... 
    
    Google Ch 12345 user  125u   REG    ... /Users/user/Library/Application Support/Google/Chrome/Default/Cookies
    
    * 123u IPv4 → сетевой сокет (соединение с сайтом)
    * 124u REG → обычный файл (кэш)
    * 125u REG → база данных cookies

Если у вас Windows, есть аналог (но не точный), который называется handle - также число, которое дает ОС процессу для работы с ресурсами. Можно погуглить, попробовать и увидеть подобную информацию

# Буфер

Дескриптор это, конечно, здорово, но читать и писать мы не можем, используя только дескриптор. Данные, которые мы читаем или пишем, не идут напрямую на диск/сеть - они идут через **буфер**

**Буфер** - это кусок оперативной памяти, куда ОС временно складывает данные, прежде чем передать их дальше

Буфер нужен, потому что:
* Работа с диском или сетью медленнее, чем с RAM (оперативка)
* Если писать каждый байт напрямую, получится огромная накладная работа

Буфер также нам позволяет копить данные и отправлять их блоками, что быстрее и эффективнее

# Чанки

**Чанк (chunk)** - кусок данных, который читается или пишется за один раз

Когда мы читаем/пишем файл или сеть, обычно разбиваем данные на чанки, чтобы не загружать слишком много памяти и оптимизировать скорость (да и буфер у нас не резиновый)

# Соединяем

1. Программа получает дескриптор на ресурс (файл, сокет)
2. При чтении/записи ОС создаёт/использует буфер для этого дескриптора
3. Программа работает с чанками данных (кусочками), которые перемещаются через буфер

# Задачи

## Задание №1

Сервер должен передать клиенту файл изображения "Crazy_Frog.jpg" размером 100Кб. Клиент должен получить файл и сохранить его под именем "received_image.jpg". Необходимо использовать размер буфера 4КБ для чтения/записи

## Задание №2

Сервер должен отправить клиенту два файла: 
* Crazy_Frog.jpg (~100 КБ) 
* fairy_tale_1kb.txt (~1 КБ) 

1. Клиент cначала читает заголовок, создаёт файл с указанным именем, читает ровно столько байт, сколько указано в размере, а затем сохраняет данные в файл
2. Размер буфера 4 КБ для изображений, 1 КБ для текста
3. Перед каждым файлом сервер отправляет заголовок в виде строки: имя_файла,размер_файла\n
   
   * имя_файла — имя файла, которое клиент сохранит
   * размер_файла — целое число, размер файла в байтах

3. Клиент должен выводить имя файла и размер в байтах после получения каждого файла



