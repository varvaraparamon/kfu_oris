Любое сетевое взаимодействие (от какого-нибудь чата до онлайн игры) — это общение двух программ по определенным правилам (протоколам). Наша с вами цель — понять эти правила и написать свои программы, которые могут общаться друг с другом

# OSI-модель

Чтобы разным устройствам было проще понимать друг друга, процесс передачи данных разбили на 7 уровней

Для нас с вами важно знать главное:

* Мы (как разрабы) работаем на **Прикладном уровне**. Мы пишем логику приложения: чата, игры, браузера и тд
* НО чтобы наше приложение могло что-то отправить, мы используем готовые инструменты с Транспортного уровня — протоколы TCP и UDP. Они отвечают за доставку наших данных

# Сравнение TCP и UDP

| Характеристика       | TCP (Transmission Control Protocol)                                     | UDP (User Datagram Protocol)                                            |
|----------------------|-------------------------------------------------------------------------|------------------------------------------------------------------------|
| **Надёжность**       | Гарантированная доставка. Потерянные пакеты переотправляются            | Отправляет и забывает. Потерянные пакеты не восстанавливаются          |
| **Порядок данных**   | Данные приходят точно в том порядке, в котором были отправлены          | Пакеты могут прийти в неправильном порядке                             |
| **Соединение**       | Устанавливает соединение («трёхстороннее рукопожатие») перед отправкой данных | Работает без установления соединения                                   |
| **Скорость**         | Медленнее из-за проверок и подтверждений                                | Быстрее, так как нет накладных расходов на установление соединения и проверки |
| **Контроль перегрузок** | Есть механизмы контроля перегрузки сети                                 | Нет механизмов контроля перегрузок                                     |
| **Примеры использования** | Веб-сайты (HTTP/S), почта (SMTP), передача файлов (FTP), удалённый доступ (SSH) | Видеостримы, онлайн-игры, голосовая связь (VoIP), DNS-запросы          |
| **Тип передачи**     | Потоковый (stream-oriented)                                             | Датаграммный (datagram-oriented)                                       |
| **Гарантия доставки** | Да                                                                      | Нет                                                                    |
| **Нагрузка на ЦП**   | Выше из-за сложной логики управления соединением                        | Ниже                                                                   |
| **Размер заголовка** | 20 байт (больше)                                                        | 8 байт (меньше)                                                        |

## Шпаргалка по выбору

### Выбирайте TCP когда:
- Важна гарантированная доставка данных (чаты, почта, веб-страницы)
- Нужна сохранность порядка данных (передача файлов)
- Работаете с протоколами HTTP, FTP, SMTP, SSH
- Соединение устойчивое и скорость не критична

### Выбирайте UDP когда:
- Важна минимальная задержка (онлайн игры, видеоконференции)
- Допустима потеря части данных (стриминг видео/аудио)
- Работаете с DNS, DHCP, VoIP
- Нужна широковещательная или multicast-передача
- Готовы реализовать свою логику надёжности поверх UDP

# Сервер

## Методы сервера
* socket.socket(family, type) — создание сокета
* AF_INET (IPv4), SOCK_STREAM (TCP), SOCK_DGRAM (UDP)
* bind((host, port)) — привязка к адресу
* listen(n) — запуск прослушивания, очередь из n клиентов
* accept() — блокирующий метод: ждёт клиента, возвращает (conn, addr)
* recv(bufsize) — блокирующий метод: чтение данных (байты)
* send(data) — отправка данных
* close() — закрытие сокета

# Переиспользование порта
Используем опцию SO_REUSEADDR, которая позволяет «переиспользовать» порт, если старый процесс уже завершён, но порт ещё висит в состоянии TIME_WAIT:
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

# Задачи на пару

## Задание №1
Модифицируйте код: Клиент должен не только получать, но и отправлять данные. 
После принятия подключения сервер должен сначала получить сообщение от клиента, напечатать его в консоль, и только потом отправить свой ответ с консоли

## Задание №2
Создайте чат. Прога позволяет серверу и клиенту вести полноценный диалог до тех пор, пока один из них не введет слово "exit". В добавок к этому сделать так, что к серверу можно было подключиться нескольким клиентам