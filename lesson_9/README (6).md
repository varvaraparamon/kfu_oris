# HTTP, библиотека requests, основы Flask, маршруты и шаблоны

## Что такое HTTP

**HTTP (HyperText Transfer Protocol)** — это протокол, по которому общаются браузер и веб-сервер

Когда вы открываете сайт:
1. Браузер отправляет запрос (HTTP Request)
2. Сервер его принимает и готовит ответ (HTTP Response)
3. Браузер получает ответ и показывает страницу

HTTP-запрос состоит из:
* метода (GET, POST…)
* URL
* заголовков
* тела (body) — у POST/PUT

Пример запроса:
```
GET /index HTTP/1.1
Host: example.com
User-Agent: Chrome
```
* GET — метод
* /index — путь
* Host — домен
* User-Agent — информация о браузере

Ответ будет что-то типо такого:
```
HTTP/1.1 200 OK
Content-Type: text/html

<html>...</html>
```
* 200 OK — код успеха
* Content-Type — тип отправляемых данных
* Далее идёт HTML

## Методы HTTP-запросов

| Метод       | Назначение                     |
| ----------- | ------------------------------ |
| **GET**     | Получение данных               |
| **POST**    | Отправка данных (формы, файлы) |
| **PUT**     | Обновление                     |
| **DELETE**  | Удаление                       |
| **PATCH**   | Частичное обновление           |
| **OPTIONS** | Информация о доступных методах |

Самые важные для нас пока что GET и POST запросы

## Библиотека request

request - либа для отправки HTTP-запросов в питончике

Давайте глянем, что мы можем с вами делать с запросами

**Отправка GET-запроса**
```python
r = requests.get("https://httpbin.org/get")
print(r.status_code)
print(r.json())
```

**GET с параметрами**
```python
r = requests.get("https://httpbin.org/get", params={"q": "python"})
print(r.json())
```
Тут по факту наш запрос превратиться в url: https://httpbin.org/get?q=python

**POST-запрос**
```python
r = requests.post("https://httpbin.org/post", data={"name": "Dinar"})
print(r.json())
```

## Веб-сервер

Веб-сервер — это программа, которая:
1. принимает HTTP-запросы
2. обрабатывает их
3. отправляет HTTP-ответ

Реальные серверы: Nginx, Apache, Gunicorn, uvicorn

Айда построим какой-то минимальный веб-сервер на сокетах наших любимых

```python
import socket

sock = socket.socket()
sock.bind(("localhost", 8080))
sock.listen()

conn, addr = sock.accept()
request = conn.recv(1024).decode()
print(request)

conn.send(b"HTTP/1.1 200 OK\n\nHello")
conn.close()
```

Чтоб посмотреть, что будет, открываем в браузере: http://localhost:8080/

Вообще важно понимать что:
* HTTP — это обычный текст
* Серверу достаточно вернуть строку с:
HTTP/1.1 200 OK
<пустая строка>
тело ответа

Flask делает всё то же самое автоматически, но удобнее!

* браузер = клиент
* сервер = программа, которая обрабатывает запросы
* Flask = инструмент для написания серверов

## Flask

Flask — это фреймворк, который упрощает создание серверов:
* автоматизирует обработку маршрутов
* сам парсит запросы
* помогает работать с HTML
* дает поддержку шаблонов

То есть Flask — это умный веб-сервер

-> Запустим наше первое Flask-приложение в first_app.py

А теперь про маршрут...

**Маршрут** - это некоторое правило типа: Если пользователь открыл URL '/', то выполнить функцию index

Естественно существуют маршруты с параметрами:

Flask может принимать значения прямо из URL
```python
@app.get("/user/<name>")
def user(name):
    return f"Hello, {name}"
```
Открыть можно по http://127.0.0.1:5000/user/Veronika

Это нужно, чтобы делать:
* страницы профилей
* страницы товаров
* новости
* категории
Ну... То есть любой динамический контент :)

А если мы хотим в HTML-шаблон вставлять данные из питона? Например, когда с БД начнем работать...

Давайте добавим шаблон

По структуре проект должен быть такой:
```python
project/
    app.py
    templates/
        items.html
```

Чтобы нам открыть эту страничку, пропишем это на нашем сервере
```python
from flask import Flask, render_template
app = Flask(__name__)

@app.get("/items")
def items():
    data = ["anya", "bulat", "hello"]
    return render_template("items.html", items=data)
```

А что теперь делаем с нашим HTML и как туда передать данные?
Есть такая вещь как шаблоны Jinja2

Заходим в HTML и можем делать следующее:

Если мы хотим вывести переменную:
```html
<p>Hello, {{ name }}</p>
```

Можем запустить цикл:
```html
{% for x in items %}
  <p>{{ x }}</p>
{% endfor %}
```

Условие:
```html
{% if user %}
  <p>Добро пожаловать, {{ user }}!</p>
{% else %}
  <p>Гость</p>
{% endif %}
```

Ну или генерировать ссылки:
```html
<a href="{{ url_for('index') }}">На главную</a>
```

А почему нельзя просто написать "/"?
* ссылки перестанут работать при изменении маршрутов
* url_for сам подставляет правильный адрес
* лучший стиль разработки

# Задачка на пару

Улучшить наше "прекрасное" приложение...

1. Добавляем страницу профиля

Добавьте маршрут:
```html
/user/<name>
```

На странице показать:
```html
Профиль пользователя <name>
```

Но не просто текст — а полноценную HTML-страницу:
* вынести в templates/user.html
* оформить через <h1>, <p> и т. д.
* вывести имя красиво: {{ name.capitalize() }} (погуглите как еще можно сделать)

2. Добавляем новую страницу - список предметов с описанием

В целом она уже есть, но стоит доработать, сделаем типа каталог

Например:
```python
data = [
    {"title": "anya", "desc": "очень умная студентка"},
    {"title": "bulat", "desc": "любит backend"},
    {"title": "hello", "desc": "слово-приветствие"}
]
```

В шаблоне items.html:
* выводите название {{ x.title }}
* выводите описание {{ x.desc }}
* оформите списком <ul> или карточками <div>

3. Добавьте страницу с формой выбора пользователя

Создайте маршрут, например:

/search

Страница должна:
* Показывать HTML-форму (метод GET) с полем username
* После отправки форма должна перенаправлять на URL:

/user/<username>

То есть:
* создаем шаблон с формой,
* используем <form method="get">,
* обрабатываем параметры через request.args

Подсказка:
```python
@app.get("/search")
def search():
    username = request.args.get("username")
    if username:
        return redirect(url_for("user", name=username))
    return render_template("search.html")
```

4. Творческое задание

Сделайте собственную страницу, которую вы бы хотели видеть в приложении





