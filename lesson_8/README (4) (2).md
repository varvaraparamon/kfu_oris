# Создание GUI-приложений с PyQt6

## Событийно-ориентированное программирование

Событийно-ориентированное программирование - это программирование, в которой выполнение программы определяется **событиями**

События - это:
* пользовательские действия (клики мышки, нажатия клавиш, движение мышки)
* системные события (таймеры, обновления интерфейса, сетевые сообщения)
* внутренние события (завершение операций, изменения данных)

Вот традиционное наше программирование (его называют линейным):
```python
def main():
    step1()
    step2()  # ждем завершения step1
    step3()  # ждем завершения step2
```

А вот событийно-ориентированное программирование:
```python
button.clicked.connect(handle_click) # настраиваем что делаем при нажатии на кнопку
```

## Установка и настройка

В терминале нашей среды разработки установим две библиотеки:
```python
pip install pyqt6 pyqt6-tools # либа для создания оконных приложений
```

Когда вы проектируете сложные приложения, для того, чтобы не мучаться (да и зачем) есть различные инструменты, которые помогают нам генерировать код этих экранчиков:
```python
pyqt6-tools designer # ДЛЯ ВИНДЫ запускаем визуальный редактор, где мы будем рисовать наш интерфейс
```

Чтобы запустить наше приложение, необходимо вызвать app.exec()

```python
app = QApplication(sys.argv)
window = QWidget()
window.setWindowTitle("Hello")
window.show()
app.exec()  # так мы запускаем наше приложение
```

Внутри себя работу exec() можно описать примерно так:
- приложение переходит в бесконечный цикл ожидания событий
- обрабатывает пользовательские действия (клики, нажатия клавиш)
- обновляет интерфейс
- ну и работает до тех пор, пока не будет вызван app.quit()

## Элементы PyQt

### Layouts

1. Vertical Layout - вертикальное расположение (сверху вниз)
2. Horizontal Layout - горизонтальное расположение (слева направо)
3. Grid Layout - сетка (строки и колонки)
4. Form Layout - форма с метками и полями ввода по типу:
Имя:       [Поле для имени]
Email:     [Поле для email]  
Телефон:   [Поле для телефона]

### Spacers 

Horizontal/Vertical Spacer - пустое пространство для выравнивания

### Buttons

1. Push Button - обычная кнопка (ОК, Отмена)
2. Tool Button - кнопка для панелей инструментов (например, в доках сверху панель инструментов)
3. Radio Button - кружок, можно выбрать только один из группы
4. Check Box - галочка, можно выбрать несколько
5. Command Link Button - большая кнопка с описанием (не поняла прикола...)
6. Dialog Button Box - готовая панель кнопок (ОК/Отмена)

### Item Views vs Item Widget

Item Views (на основе моделей) - для больших данных
* List/Tree/Table View - отображают данные из базы/файлов

Item Widgets (готовые виджеты) - для простых случаев
* List/Tree/Table Widget - встроенное хранение данных

### Containers

1. Group Box - группа с рамкой и заголовком
2. Scroll Area - область с прокруткой
3. Tool Box - выдвижные панели (как аккордеон)
4. Tab Widget - вкладки
5. Stacked Widget - "стопка" виджетов (показывается один)
6. Frame - простая рамка
7. Widget - пустой контейнер
8. MDI Area - область для нескольких окон внутри приложения
9. Dock Widget - плавающие панели (как в IDE)

### Input Widgets

1. Combo Box - выпадающий список
2. Font Combo Box - выбор шрифта
3. Line Edit - одна строка текста
4. Text Edit - многострочный текст с форматированием
5. Plain Text Edit - многострочный текст без форматирования
6. Spin Box - выбор числа (стрелочки)
7. Double Spin Box - выбор дробного числа
8. Time/Date/DateTime Edit - выбор времени и даты
9. Dial - круговой регулятор
10. Scroll Bar / Slider - ползунки
11. Key Sequence Edit - ввод комбинации клавиш

### Display Widgets

1. Label - текст или картинка
2. Text Browser - просмотр HTML/текста
3. Graphics View - область для сложной графики
4. Calendar Widget - календарь
5. LCD Number - цифры как в электронных часах
6. Progress Bar - индикатор выполнения
7. Horizontal/Vertical Line - разделительная линия
8. OpenGL Widget - для 3D графики

## Совместная задача - Task Manager

Создать TaskManager:
- Пишем название задачи
- Выбираем приоритет задачи
- Кнопка "Добавить"
- Список со скроллингом задач
- Возможность отметить, что задача выполнена
- Кнопка "Удалить"

## Лабораторная работа
- Как добавить сокетное подключение? 
Все клиенты подключаются и у них один и тот же список задач, они все его могут менять

**Этап 1: Разделяем сервер и клиента**

Сервер хранит:
* Список задач
* Обрабатывает добавление, удаление и изменение задач
* Рассылает обновления всем подключенным клиентам

Клиент:
* Отправляет серверу новые задачи или команды на удаление
* Получает обновления и показывает их в GUI

**Этап 2: Протокол обмена**

Как всегда используем TCP-сокеты

Протокол обмена — простой текстовый JSON:
```json
{"action": "add", "text": "Купить хлеб", "priority": "high"}
{"action": "delete", "index": 0}
{"action": "update", "completed": true, "index": 1}

```
После каждой команды сервер рассылает клиентам весь обновленный список задач

**Этап 3: Создание сервера**
1. Создать сервер с потоками для обслуживания нескольких клиентов
2. Хранить задачи в глобальном списке tasks
3. Реализовать функции:
   * broadcast_tasks() — отправка списка всем клиентам
   * handle_client(conn) — обработка команд от одного клиента

**Этап 4: Создание клиента**
1. Создать класс TaskClient, который:
   * Подключается к серверу
   * Слушает обновления (listen_server)
   * Отправляет команды (send_command)
2. Клиент хранит локальный список задач self.tasks

**Этап 5: Интеграция с нашим PyQt**
1. Подключите PyQt GUI к TaskClient
2. Вместо локального списка QListWidget используйте данные из self.client.tasks
3. Реализуйте отправку команд при добавлении, удалении и отметке выполнения
4. Метод update_gui() должен перерисовывать QListWidget по текущему списку задач